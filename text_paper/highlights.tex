\section{Highlights}

\subsection{``Real'' EARS}

EARS was not originally built to describe requirements at a level where they can
automatically be transposed into a real system. As such, an effort had to be
made in order to overcome the semantic gap between on the one hand the
structured but non-formal nature of EARS, and on the other hand the strictly
formal nature of the Linear Temporal Logic (LTL) formalism needed by the
automated synthesis mechanisms.


\begin{figure}[h!]
   \begin{center}
     \includegraphics[width=1\textwidth]{images/EARS-Reqs.png}
     \caption{\textsf{EARS-CTRL} Requirements for a sliding door
     controller}
     \label{fig:ears_reqs}
   \end{center}
 \end{figure}
 
Figure~\ref{fig:ears_reqs} illustrates a set of \textsf{EARS-CTRL} requirements 
for the software controller for a sliding door. By remaining as close as
possible to the original EARS syntax our editor allows building requirements as
correct English sentences that can easily be written and understood by humans.
In fact, given the requirements stated in figure~\ref{fig:ears_reqs}, no
additional explanations are necessary for a human to understand the behavior of
the sliding door controller that should be generated.

\begin{figure}[h!]
\begin{center}
\textbf{When} $\langle$trigger$\rangle$ \textbf{then the}
$\langle$system name$\rangle$ \textbf{shall}
$\langle$response$\rangle$ \textbf{until}
$\langle$trigger$\rangle$.
\caption{An non-standard state-driven EARS template including an \emph{until}
clause.}
\label{fig:ears_template_while}
\end{center}
\end{figure}

In~\cite{LucioRCM17} we have presented a previous version of \textsf{EARS-CTRL}
which included templates that, although not part of the original EARS, had been
introduced to simplify translation into LTL.  An example of one such templates
is presented in figure~\ref{fig:ears_template_while} -- the \textbf{while} segment of the
requirement is not standard EARS and has been removed in the version of
\textsf{EARS-CTRL} we present in this paper. The work of briging the syntax of
\textsf{EARS-CTRL} closer to ``real'' EARS while preserving a semantically
meaniful translation into LTL was done with together with Alistair Mavin, the
author of this paper who is also the main proponent of EARS~\cite{EARS09}.
Our rationale is that, by remaining as faithful as possible to the original
EARS syntax, we: 1) benefit from all the advantages of using EARS already
investigated and described in the literature~\cite{EARS09,EARS16}; and 2)
provide to Rolls-Royce and potentially other companies a tool that can
immediately be used by engineers trained in the use of EARS.

% , thus
% retaining its advantages of \ldots, as described in~\cite{}. In such as manner our tool benefits from all the research
% and advantages of EARS described in the literature~\cite{}.

% One of the main goals of our approach is to  In order to be able
% to ``write'' EARS-like requirements, a first analysis of the problem needs to be
% done in the shape of the creation of a of glossary for the problem at hand.
%
% 
% In order to reach a functioning controller we then allow interacting with the
% automatically generated synthesizer using Simulink. When necessary the engineer
% can edit the EARS requirements, where necessary, to be able to generate
% controllers exhibiting the expected behavior. This may come at the cost of
% sacrificing some of the readabilty of the original EARS
% requirements.\levi{blahblah}

\subsection{A Push-Button Approach}

Controllers can be fully automatically synthesized from EARS requirements into
controllers, at the push of a button. Note that in order to build requirements
model illustrated in figure~\ref{fig:ears_reqs} it is necessary to, as a first
step, build a glossary for the controller. Such a glossary identifies the
components of the system to be controlled. Each one of those components contains
actuators and (possibly) sensors that will be used by the controller logic
as, respectively, inputs from and outputs to the real system. The vocabulary
defined in the glossary is appropriately proposed by the \textsf{EARS-CTRL} IDE
to fill in the placeholders when a new requirement is built.

\begin{figure}[h!]
   \begin{center}
     \includegraphics[width=.5\textwidth]{images/glossary.png}
     \caption{\textsf{EARS-CTRL} Glossary for sliding door
     controller\levi{make distinction between invariants and aliases}}
     \label{fig:ears_glossary}
   \end{center}
 \end{figure}
 
 We present in figure~\ref{fig:ears_glossary} the glossary for the automatic
 door controller specification. Note that the glossary allows defining
 invariants that will be taken into consideration during controller synthesis:
 for example in the last line of glossary in figure~\ref{fig:ears_glossary} we
 state that if the motor is \textsf{stopped}, it cannot be \textsf{opening} or
 \textsf{closing}.

\subsection{Verification}

% Our \textsf{EARS-CTRL} tool provides a set of mechanisms for verification, in
% particular \emph{Well-Formedness by Construction} when the specification is
% being built and \emph{simulation} of the synthesized controllers by exercising the
% controller manually using \textsf{simulink} as a back-end. We can also generate
% test cases for controllers that can either be used to debug the controller by
% analysing traces of execution of the controller or to be used as test-cases for
% alternative implementations of the controllers which are not automatically
% synthesized.

\subsubsection{Well-Formedness by Construction}

Well-formedness by construction is enforced in two different ways by
\textsf{EARS-CTRL}: firstly, only valid EARS requirement patterns can be added
to a requirements specification. When the requirements engineer picks an EARS
template for her new requirement, the corresponding sentence is displayed by the
IDE as a structure with placeholders. Such structures provide a first level of
well-formedness, as only correctly formed EARS patterns can be added to the
specification. Secondly, only valid sensors or actuators can be picked to fill
in the placeholders in an EARS requirement.

Because well-formedness is enforced by construction, requirement specifications
written in \textsf{EARS-CTRL} are always syntactically correct. The semantics of
such specifications is then given by the \textsf{autoConf4}~\cite{autoCode17}
synthesizer in the form of a synchronous dataflow (SDF) diagram, which
\textsf{EARS-CTRL} can display graphically. In the cases where synthesis is not
possible the error code from the \textsf{autoConf4} tool is lifted such that the
requirements that prevent the controller from being generated are pointed out.
\levi{this is not done yet}

\subsubsection{Simulation}

\begin{figure}[h!]
   \begin{center}
     \includegraphics[width=1\textwidth]{images/simulation.png}
     \caption{\textsf{EARS-CTRL} specification simulator\levi{sync picture
     with text}}
     \label{fig:ears_simulator}
   \end{center}
 \end{figure}

Once a controller has been synthesized from a set of EARS requirements, it
becomes important to understand whether it behaves as expected. In order to do
so we have used the Simulink engine~\cite{simulink} as a simulation back-end.
In figure~\ref{fig:ears_simulator} we display the \textsf{EARS-CTRL} panel that
allows ``playing'' the controller by providing a sequence of inputs manually.
Outputs are incrementally added to the panel as new inputs are provided by the
requirements engineer. Note that, because controllers have internal state,
the order in which the commands influences the controller's output. A ``Reset''
button in the panel allows resetting the controller to its initial state.

\subsubsection{Generation of Test Cases}

\textsf{EARS-CTRL} allows generating test cases directly from the EARS
requirements. A test case consists of a sequence of $\langle
input, output \rangle$ pairs, where each input is a vector of sensor states
and each output a vector of actuator states. Note that individual sensors and
actuators can assume two states: ``0'': off; ``1'': on. Test case generation
is parameterized by providing the following values:

\begin{itemize}
  \item \emph{Test Sequence Length:} defines the maximum length of the $\langle
  input, output \rangle$ pair sequences to be generated.
  \item \emph{Allow parallel inputs:} enables or disables the possibility of
  having more than one sensor being active for inputs in the test case.
  \item \emph{Allow repeated inputs:} enables or disables having repeated inputs
  in the same test sequence. When enabled this parameter makes it such that
  an input vector cannot occur more than once in a test sequence -- thus
  limiting the length of test sequences to the number of possible input vectors.
\end{itemize} 

\subsection{Code Generation}

Generation of C code can be achieved by running Simulink's code generator on the
Simulink model that is generated from the requirements EARS expressed in 
\textsf{EARS-CTRL}.
